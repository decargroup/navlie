<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Toy Problem - Traditional Approach &#8212; navlie 0.1.0 documentation</title>
    
  <link href="../_static/css/theme.css" rel="stylesheet">
  <link href="../_static/css/index.ff1ffe594081f20da1ef19478df9384b.css" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      

    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=8f2a1f02" />
    <link rel="stylesheet" type="text/css" href="../_static/css/blank.css?v=c4c5097c" />
    <link rel="stylesheet" type="text/css" href="../_static/nbsphinx-code-cells.css?v=2aa19091" />
    
  <link rel="preload" as="script" href="../_static/js/index.be7d3bbb2ef33a8344ce.js">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js?v=40769cce"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=4825356b"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Toy Problem - Lie group approach" href="lie_groups.html" />
    <link rel="prev" title="Getting Started" href="../tutorial.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    
    <div class="container-fluid" id="banner"></div>

    
    <nav class="navbar navbar-light navbar-expand-lg bg-light fixed-top bd-navbar" id="navbar-main"><div class="container-xl">

  <div id="navbar-start">
    
    
<a class="navbar-brand" href="../index.html">
<p class="title">navlie</p>
</a>

    
  </div>

  <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbar-collapsible" aria-controls="navbar-collapsible" aria-expanded="false" aria-label="Toggle navigation">
    <span class="navbar-toggler-icon"></span>
  </button>

  
  <div id="navbar-collapsible" class="col-lg-9 collapse navbar-collapse">
    <div id="navbar-center" class="mr-auto">
      
      <div class="navbar-center-item">
        <ul id="navbar-main-elements" class="navbar-nav">
    <li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../index.html">
  Home
 </a>
</li>

<li class="toctree-l1 current active nav-item">
 <a class="reference internal nav-link" href="../tutorial.html">
  Tutorial
 </a>
</li>

<li class="toctree-l1 nav-item">
 <a class="reference internal nav-link" href="../api.html">
  API
 </a>
</li>

    
</ul>
      </div>
      
    </div>

    <div id="navbar-end">
      
      <div class="navbar-end-item">
        <ul id="navbar-icon-links" class="navbar-nav" aria-label="Icon Links">
      </ul>
      </div>
      
    </div>
  </div>
</div>
    </nav>
    

    <div class="container-xl">
      <div class="row">
          
            
            <!-- Only show if we have sidebars configured, else just a small margin  -->
            <div class="col-12 col-md-3 bd-sidebar"><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search the docs ..." aria-label="Search the docs ..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
  <div class="bd-toc-item active">
    <ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../tutorial.html">
   1. Getting Started
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   2. Toy Problem - Traditional
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="lie_groups.html">
   3. Toy Problem - Lie groups
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="jacobians.html">
   4. Specifying Jacobians
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="composite.html">
   4. Composite States
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="batch.html">
   Toy Batch SLAM Example
  </a>
 </li>
</ul>

  </div>
</nav>
            </div>
            
          

          
          <div class="d-none d-xl-block col-xl-2 bd-toc">
            
              
              <div class="toc-item">
                
<div class="tocsection onthispage pt-5 pb-3">
    <i class="fas fa-list"></i> On this page
</div>

<nav id="bd-toc-nav">
    <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#Define-the-State">
   Define the State
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#Define-the-Process-Model">
   Define the Process Model
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#Define-the-Measurement-Model(s)">
   Define the Measurement Model(s)
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#(Simulation-only)-Generate-fake-data">
   (Simulation only) Generate fake data
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#Run-a-filter!">
   Run a filter!
  </a>
 </li>
</ul>

</nav>
              </div>
              
              <div class="toc-item">
                
              </div>
              
            
          </div>
          

          
          
            
          
          <main class="col-12 col-md-9 col-xl-7 py-md-5 pl-md-5 pr-md-4 bd-content" role="main">
              
              <div>
                
  <section id="Toy-Problem---Traditional-Approach">
<h1>Toy Problem - Traditional Approach<a class="headerlink" href="#Toy-Problem---Traditional-Approach" title="Permalink to this heading">¶</a></h1>
<p>In this tutorial, we’ll simulate a simple 2D localization problem as per the figure below. We’ll assume that we have a robot following a simple body-frame-velocity model, which has access to noisy measurements of its forward velocity <span class="math notranslate nohighlight">\(v\)</span> and angular velocity <span class="math notranslate nohighlight">\(\omega\)</span>. In addition, this robot will have a time-of-flight sensor that gives it range measurements to a few known landmarks in the environment.</p>
<img alt="Toy Problem" src="../_images/toy_problem.png" />
<section id="Define-the-State">
<h2>Define the State<a class="headerlink" href="#Define-the-State" title="Permalink to this heading">¶</a></h2>
<p>The first step is to define the state of the robot. We’ll start with a more traditional approach and define the state of the robot to be a vector of the form <span class="math notranslate nohighlight">\(\mathbf{x} = [\theta, x, y ]^T\)</span>, where <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> are the robot’s position in the world and <span class="math notranslate nohighlight">\(\theta\)</span> is its orientation. We’ll also define the control inputs to be <span class="math notranslate nohighlight">\(\mathbf{u} = [\omega, v]^T\)</span>, the robot’s forward and angular velocity. The process (motion) model of the robot is then given by:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
    \dot{\theta} &amp;= \omega,\\
    \dot{x} &amp;= v \cos(\theta), \\
    \dot{y} &amp;= v \sin(\theta).
\end{aligned}\end{split}\]</div>
<p>However, this is in continuous time, and we need to discretize it to use it in a filter. For now, we’ll use the simple Euler discretization method, which gives us the following discrete-time process model:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{aligned}
    \theta_{k+1} &amp;= \theta_k + \omega_k \Delta t, \\
    x_{k+1} &amp;= x_k + v_k \cos(\theta_k) \Delta t, \\
    y_{k+1} &amp;= y_k + v_k \sin(\theta_k) \Delta t.
\end{aligned}\end{split}\]</div>
<p>Lets now code up our state and process model using navlie’s framework. Since our state is just a regular 3x1 vector, we can use a standard type from the built-in library: <a class="reference internal" href="../_autosummary/navlie.lib.states.VectorState.html"><span class="doc">navlie.lib.VectorState</span></a></p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">navlie</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">nav</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">navlie.lib</span><span class="w"> </span><span class="kn">import</span> <span class="n">VectorState</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">VectorState</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">stamp</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
VectorState(stamp=0.0, dof=3, state_id=None)
    [0. 0. 0.]
</pre></div></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">VectorState</span></code> is a subclass of the abstract <a class="reference internal" href="../_autosummary/navlie.types.State.html"><span class="doc">State</span></a> class in navlie, which is one of the core primitive types. The value of the state is stored as a numpy array, and can be accessed directly through <code class="docutils literal notranslate"><span class="pre">x.value</span></code>.</p>
</section>
<section id="Define-the-Process-Model">
<h2>Define the Process Model<a class="headerlink" href="#Define-the-Process-Model" title="Permalink to this heading">¶</a></h2>
<p>For the process model, we’ll choose to define our own from scratch here. Process models in navlie <em>must</em> inherit from the abstract <a class="reference internal" href="../_autosummary/navlie.types.ProcessModel.html"><span class="doc">navlie.ProcessModel</span></a> class and implement the <code class="docutils literal notranslate"><span class="pre">evaluate</span></code> and either the <code class="docutils literal notranslate"><span class="pre">input_covariance</span></code> or <code class="docutils literal notranslate"><span class="pre">covariance</span></code> methods.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">navlie.lib</span><span class="w"> </span><span class="kn">import</span> <span class="n">VectorInput</span>

<span class="n">Q</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.1</span><span class="o">**</span><span class="mi">2</span> <span class="c1"># Input noise covariance with 0.1 m/s of standard deviation</span>

<span class="k">class</span><span class="w"> </span><span class="nc">WheeledRobot</span><span class="p">(</span><span class="n">nav</span><span class="o">.</span><span class="n">ProcessModel</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_covariance</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Q</span> <span class="o">=</span> <span class="n">input_covariance</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">VectorState</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">VectorInput</span><span class="p">,</span> <span class="n">dt</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">VectorState</span><span class="p">:</span>
        <span class="n">x_next</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">x_next</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">u</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">dt</span>
        <span class="n">x_next</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="n">u</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">x_next</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+=</span> <span class="n">u</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">x_next</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">input_covariance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">VectorState</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="n">VectorInput</span><span class="p">,</span> <span class="n">dt</span><span class="p">:</span> <span class="nb">float</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Q</span>

<span class="n">process_model</span> <span class="o">=</span> <span class="n">WheeledRobot</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span> <span class="c1"># instantiate it</span>
</pre></div>
</div>
</div>
<p>The methods in navlie process models must always accept the arguments shown above: a <code class="docutils literal notranslate"><span class="pre">State</span></code> object, an <code class="docutils literal notranslate"><span class="pre">Input</span></code> object, and a float <code class="docutils literal notranslate"><span class="pre">dt</span></code>. The <code class="docutils literal notranslate"><span class="pre">evaluate</span></code> method must always return a valid (i.e. subclass of a) <code class="docutils literal notranslate"><span class="pre">State</span></code> object, and the <code class="docutils literal notranslate"><span class="pre">input_covariance</span></code> method must always return a square numpy array. There are more optional methods that can be implemented for performance reasons, but we will cover those later.</p>
</section>
<section id="Define-the-Measurement-Model(s)">
<h2>Define the Measurement Model(s)<a class="headerlink" href="#Define-the-Measurement-Model(s)" title="Permalink to this heading">¶</a></h2>
<p>Moving on to the measurement model, if <span class="math notranslate nohighlight">\(\mathbf{r}_a = [x,y]^T\)</span> denotes the position vector of the robot resolved in the world frame, and <span class="math notranslate nohighlight">\(\mathbf{\ell}^{(i)}_{a} \in \mathbb{R}^2\)</span> is the 2 x 1 position vector of landmark <span class="math notranslate nohighlight">\(i\)</span>, then the measurement model for each landmark is simply</p>
<div class="math notranslate nohighlight">
\[y_i = ||\mathbf{r}_a - \mathbf{\ell}^{(i)}_{a}||\]</div>
<p>In navlie, measurement models must be implemented in a similar way to process models: inherit from the <a class="reference internal" href="../_autosummary/navlie.types.MeasurementModel.html"><span class="doc">navlie.MeasurementModel</span></a> abstract class, and then implement the <code class="docutils literal notranslate"><span class="pre">evaluate</span></code> and <code class="docutils literal notranslate"><span class="pre">covariance</span></code> methods. Here’s an example for this problem:</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[23]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span><span class="w"> </span><span class="nc">RangeToLandmark</span><span class="p">(</span><span class="n">nav</span><span class="o">.</span><span class="n">MeasurementModel</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">landmark_position</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">landmark_position</span> <span class="o">=</span> <span class="n">landmark_position</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">evaluate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">VectorState</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">landmark_position</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">covariance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">VectorState</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="mf">0.1</span><span class="o">**</span><span class="mi">2</span>

<span class="n">landmarks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="n">meas_models</span> <span class="o">=</span> <span class="p">[</span><span class="n">RangeToLandmark</span><span class="p">(</span><span class="n">landmark</span><span class="p">)</span> <span class="k">for</span> <span class="n">landmark</span> <span class="ow">in</span> <span class="n">landmarks</span><span class="p">]</span>
</pre></div>
</div>
</div>
</section>
<section id="(Simulation-only)-Generate-fake-data">
<h2>(Simulation only) Generate fake data<a class="headerlink" href="#(Simulation-only)-Generate-fake-data" title="Permalink to this heading">¶</a></h2>
<p>The next step is to generate some fake data for our simulation (although navlie is also compatible with real data). To do this, we will use the <a class="reference internal" href="../_autosummary/navlie.datagen.DataGenerator.html"><span class="doc">DataGenerator</span></a> class which is used as follows</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[24]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dg</span> <span class="o">=</span> <span class="n">nav</span><span class="o">.</span><span class="n">DataGenerator</span><span class="p">(</span>
    <span class="n">process_model</span><span class="o">=</span><span class="n">process_model</span><span class="p">,</span>                  <span class="c1"># process model to use</span>
    <span class="n">input_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]),</span> <span class="c1"># a callable that specifies the input values over time</span>
    <span class="n">input_covariance</span><span class="o">=</span> <span class="n">Q</span><span class="p">,</span>                          <span class="c1"># numpy array or callable that specifies the input covariance over time</span>
    <span class="n">input_freq</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span>                                <span class="c1"># the frequency (Hz) at which the input is sampled (and the process model integrated)</span>
    <span class="n">meas_model_list</span><span class="o">=</span><span class="n">meas_models</span><span class="p">,</span>                  <span class="c1"># a list of measurement models to use</span>
    <span class="n">meas_freq_list</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">]</span>               <span class="c1"># corresponding measurement frequencies (Hz)</span>
<span class="p">)</span>

<span class="n">state_data</span><span class="p">,</span> <span class="n">input_data</span><span class="p">,</span> <span class="n">meas_data</span> <span class="o">=</span> <span class="n">dg</span><span class="o">.</span><span class="n">generate</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="mi">30</span><span class="p">,</span> <span class="n">noise</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">state_data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">input_data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="nb">print</span><span class="p">(</span><span class="n">meas_data</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
VectorState(stamp=0.0, dof=3, state_id=None)
    [0. 0. 0.]
VectorInput(stamp=0.0, state_id=None)
    [0.4867558  0.40227221]
Measurement(stamp=0.0, state_id=None) of RangeToLandmark
    1.5906187969698615
</pre></div></div>
</div>
<p>The output of the <code class="docutils literal notranslate"><span class="pre">DataGenerator.generate</span></code> method is three lists: a list of ground-truth <code class="docutils literal notranslate"><span class="pre">State</span></code> objects, a list of <code class="docutils literal notranslate"><span class="pre">Input</span></code> objects, and a list of <a class="reference internal" href="../_autosummary/navlie.types.Measurement.html"><span class="doc">Measurement</span></a> objects, with the input/measurement lists possibly being corrupted by random noise if the <code class="docutils literal notranslate"><span class="pre">noise=True</span></code> flag is set. Each item in these lists correspond to different points in time. We can plot the trajectory as follows</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[25]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span>

<span class="c1"># Plot the state trajectory</span>
<span class="n">pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">state</span><span class="o">.</span><span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">state_data</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">pos</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">pos</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">landmarks</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">landmarks</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
<span class="c1"># add labels</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">landmark</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">landmarks</span><span class="p">):</span>
    <span class="n">plt</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Landmark </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">landmark</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Simulated Trajectory&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s2">&quot;equal&quot;</span><span class="p">)</span>


<span class="c1"># Plot the input data</span>
<span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
<span class="n">u_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">u</span><span class="o">.</span><span class="n">value</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">input_data</span><span class="p">])</span>
<span class="n">u_stamps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">u</span><span class="o">.</span><span class="n">stamp</span> <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">input_data</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">u_stamps</span><span class="p">,</span> <span class="n">u_array</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;omega&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">u_stamps</span><span class="p">,</span> <span class="n">u_array</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="s2">&quot;v&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;Time (s)&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Input&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s2">&quot;Input Data&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
<br/></pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/tutorial_traditional_9_0.png" src="../_images/tutorial_traditional_9_0.png" />
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/tutorial_traditional_9_1.png" src="../_images/tutorial_traditional_9_1.png" />
</div>
</div>
</section>
<section id="Run-a-filter!">
<h2>Run a filter!<a class="headerlink" href="#Run-a-filter!" title="Permalink to this heading">¶</a></h2>
<p>Finally, lets run an extended Kalman filter on this data to get a state estimate that uses only the noisy measurements. In the below filter, we instantiate the <a class="reference internal" href="../_autosummary/navlie.filters.ExtendedKalmanFilter.html"><span class="doc">ExtendedKalmanFilter</span></a> to use on our data, and looping over the input measurements while also calling the correction step whenever a measurement occurs.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[26]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># First, define the filter</span>
<span class="n">kalman_filter</span> <span class="o">=</span> <span class="n">nav</span><span class="o">.</span><span class="n">ExtendedKalmanFilter</span><span class="p">(</span><span class="n">process_model</span><span class="p">)</span>

<span class="c1"># You can try other filters too!</span>
<span class="c1"># kalman_filter = nav.UnscentedKalmanFilter(process_model)</span>
<span class="c1"># kalman_filter = nav.IteratedKalmanFIlter(process_model)</span>

<span class="n">P0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mf">0.1</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="o">**</span><span class="mi">2</span><span class="p">])</span>  <span class="c1"># Initial covariance</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">nav</span><span class="o">.</span><span class="n">StateWithCovariance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">P0</span><span class="p">)</span>  <span class="c1"># Estimate and covariance in one container</span>

<span class="n">meas_idx</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">meas_data</span><span class="p">[</span><span class="n">meas_idx</span><span class="p">]</span>
<span class="n">estimates</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">input_data</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">input_data</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

    <span class="c1"># Fuse any measurements that have occurred.</span>
    <span class="k">while</span> <span class="n">y</span><span class="o">.</span><span class="n">stamp</span> <span class="o">&lt;</span> <span class="n">input_data</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">stamp</span> <span class="ow">and</span> <span class="n">meas_idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">meas_data</span><span class="p">):</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">correct</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>

        <span class="c1"># Load the next measurement</span>
        <span class="n">meas_idx</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">meas_idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">meas_data</span><span class="p">):</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">meas_data</span><span class="p">[</span><span class="n">meas_idx</span><span class="p">]</span>

    <span class="c1"># Predict until the next input is available</span>
    <span class="n">dt</span> <span class="o">=</span> <span class="n">input_data</span><span class="p">[</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">stamp</span> <span class="o">-</span> <span class="n">x</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">stamp</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">kalman_filter</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>

    <span class="n">estimates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
</pre></div>
</div>
</div>
<p>The filters in navlie are all designed to be <em>stateless</em>: this means that the actual state estimate is stored externally to the filter objects, in this case in a container called <a class="reference internal" href="../_autosummary/navlie.types.StateWithCovariance.html"><span class="doc">StateWithCovariance</span></a>. Although this adds a slight burden on the user, it has the advantage of being more transparent, and also providing the ability to combine different filters in the same loop! For example, you could use an EKF for the prediction, but a UKF for
the correction, or even to use different filters for different measurement models!</p>
<p>Once estimates have been obtained, we will often be interested in evaluating the performance. The <a class="reference external" href="../_autosummary/navlie.utils.GaussianResultList.rst">GaussianResultList</a> object is a useful container for evaluating the quality of the state estimates when ground truth data is available. It calculates useful metrics such as raw error, Mahalanobis distance, and normalized estimation error squared (NEES).</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[27]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">results</span> <span class="o">=</span> <span class="n">nav</span><span class="o">.</span><span class="n">GaussianResultList</span><span class="o">.</span><span class="n">from_estimates</span><span class="p">(</span><span class="n">estimates</span><span class="p">,</span> <span class="n">state_data</span><span class="p">)</span>
<span class="c1"># results.nees</span>
<span class="c1"># results.three_sigma</span>
<span class="c1"># results.error</span>
<span class="c1"># results.md # mahalanobis distance</span>
<span class="c1"># # and more...</span>

<span class="c1"># Some plotting functions that work directly with GaussianResultList</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">axs</span> <span class="o">=</span> <span class="n">nav</span><span class="o">.</span><span class="n">plot_error</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
<span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Estimation Errors&quot;</span><span class="p">)</span>
<span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;theta (rad)&quot;</span><span class="p">)</span>
<span class="n">axs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;x (m)&quot;</span><span class="p">)</span>
<span class="n">axs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s2">&quot;y (m)&quot;</span><span class="p">)</span>
<span class="n">axs</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Time (s)&quot;</span><span class="p">)</span>

<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">nav</span><span class="o">.</span><span class="n">plot_nees</span><span class="p">(</span><span class="n">results</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;NEES&quot;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s2">&quot;Time (s)&quot;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/tutorial_traditional_13_0.png" src="../_images/tutorial_traditional_13_0.png" />
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/tutorial_traditional_13_1.png" src="../_images/tutorial_traditional_13_1.png" />
</div>
</div>
<p>As a final note, <code class="docutils literal notranslate"><span class="pre">GaussianResultList</span></code> will invoke the <code class="docutils literal notranslate"><span class="pre">State.minus</span></code> method of the state objects to calculate the error. As we will see next, this allows us to implement a custom measure of error, when it might not make sense to directly subtract two of our state objects.</p>
</section>
</section>


              </div>
              
              
              <!-- Previous / next buttons -->
<div class='prev-next-area'> 
    <a class='left-prev' id="prev-link" href="../tutorial.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title">Getting Started</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="lie_groups.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title">Toy Problem - Lie group approach</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
              
          </main>
          

      </div>
    </div>
  
  <script src="../_static/js/index.be7d3bbb2ef33a8344ce.js"></script>
<footer class="footer mt-5 mt-md-0">
  <div class="container">
    
    <div class="footer-item">
      <p class="copyright">
    &copy; Copyright 2022.<br>
</p>
    </div>
    
    <div class="footer-item">
      <p class="sphinx-version">
Created using <a href="http://sphinx-doc.org/">Sphinx</a> 7.1.2.<br>
</p>
    </div>
    
  </div>
</footer>
  </body>
</html>